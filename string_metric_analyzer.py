import os
import time
import argparse
import json
from subprocess import check_output
from itertools import cycle

from Bio import SeqIO
import numpy as np
import matplotlib.pyplot as plt


class Timer:

    def __enter__(self):
        self.start = time.clock()
        return self

    def __exit__(self, *args):
        self.end = time.clock()
        self.interval = self.end - self.start


def get_parser():
    parser = argparse.ArgumentParser(
        description='String metric analyzer based on output from seq_generator.py')
    parser.add_argument(
        'source', action="store", help="Folder generated by seq_generator.py")
    parser.add_argument('metrics', action="store",
                        help="JSON file like {'string_metrics':[metric1, metric2,...]}\
                        where metric{i} is executed with args [seq1, seq2] and match is output")
    parser.add_argument(
        '-d', '--dest', action="store", default="output_metric_analyzer", help="Destination folder")
    return parser


def extract_from_title(title):
    # len_100_p_0.1_1{json}
    splited = title.split("_")
    lenght = int(splited[1])
    p = float(splited[3])
    split_point = splited[4].index("{")
    i = int(splited[4][:split_point])
    diffs = json.loads(splited[4][split_point:])
    return lenght, p, i, diffs

def draw_time_graph(report, dest):
    fig = plt.figure()
    ax = plt.subplot(111)

    for i, metric in enumerate(report):

        lenghts = report[metric]["lenghts"].keys()
        lenghts.sort()
        times = [report[metric]["lenghts"][lenght]["time"] for lenght in lenghts]
        index = np.arange(len(lenghts))

        bar_width = 1.0 / len(report)
        opacity = 0.4

        color = _COLORS.next()
        ax.bar(index + i * bar_width, times, bar_width,
                alpha=opacity,
                color=color,
                label=metric)
        plt.xticks(index + bar_width * len(report) / 2.0, lenghts)

    plt.xlabel('Sequence lenght')
    plt.ylabel('Time for all sequences [s]')
    plt.title('Time comparison')
    # Shrink current axis's height by 10% on the bottom
    box = ax.get_position()
    ax.set_position([box.x0, box.y0 + box.height * 0.1,
                 box.width, box.height * 0.9])

    # Put a legend below current axis
    ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15),
          fancybox=True, shadow=True, ncol=5)

    plt.savefig(dest + "/times.png")

def draw_analysis_graph(report, dest):
    for metric in report:
        fig, ax = plt.subplots()
        lenghts = report[metric]["lenghts"].keys()
        lenghts.sort()
        for lenght in lenghts:
            color = _COLORS.next()
            error_probs = [
                error_prob for error_prob in report[metric]["lenghts"][lenght]["error_probs"]]
            error_probs.sort()
            percentages = [(pair["total"] - pair["bad"]) * 100.0 / pair["total"] for pair in [
                report[metric]["lenghts"][lenght]["error_probs"][error_prob] for error_prob in error_probs]]

            plt.plot([error_prob * 100 for error_prob in error_probs], percentages, marker='o', color=color, label=lenght)

        plt.ylabel('Percentage of correct similarity match')
        plt.xlabel('Percentage difference from base sequence')
        plt.title(metric)

        plt.legend()
        plt.tight_layout()
        plt.ylim([0,100])
        plt.savefig(dest + "/" + metric.replace("/", "_") + ".png")


def main():
    args = get_parser().parse_args()
    with open(args.metrics) as json_file:
        try:
            config = json.load(json_file)
        except ValueError:
            print "Config file is not in json format"
            exit()
    if not all(param in config for param in ["string_metrics"]):
        print "Config file missing parameters"
        exit()

    if not os.path.isdir(args.dest):
        os.mkdir(args.dest)
    report = {}
    for metric in config["string_metrics"]:
        report.update({metric: {"lenghts": {}, "time": 0}})
        for record in SeqIO.parse(args.source + "/all.fa", "fasta"):
            lenght, error_prob, index, diffs = extract_from_title(
                record.description)
            # set report statistics if lenght or error probability apears for
            # the first time
            if lenght not in report[metric]["lenghts"]:
                report[metric]["lenghts"].update(
                    {lenght: {"error_probs": {error_prob: {"bad": 0, "total": 0, "time": 0}}, "time": 0}})

            if error_prob not in report[metric]["lenghts"][lenght]["error_probs"]:
                report[metric]["lenghts"][lenght]["error_probs"].update(
                    {error_prob: {"bad": 0, "total": 1, "time": 0}})
            else:
                report[metric]["lenghts"][lenght][
                    "error_probs"][error_prob]["total"] += 1

            # get apropriate base record
            for base_records in SeqIO.parse("%s/len_%d_base.fa" % (args.source, lenght), "fasta"):
                base_record = base_records
                break

            # use metric to get match percentage
            with Timer() as t:
                if metric.endswith(".py"):
                    match = float(
                        check_output(["python", str(metric), str(record.seq), str(base_record.seq)]))
                else:
                    match = float(
                        check_output([str(metric), str(record.seq), str(base_record.seq)]))

            # add time to report
            report[metric]["lenghts"][lenght]["error_probs"][
                error_prob]["time"] += t.interval
            report[metric]["lenghts"][lenght]["time"] += t.interval
            report[metric]["time"] += t.interval

            if abs(1 - match - error_prob) > _ERROR_MARGIN:
                report[metric]["lenghts"][lenght][
                    "error_probs"][error_prob]["bad"] += 1

    with open("%s/report.json" % (args.dest), 'w') as fout:
        json.dump(report, fout, indent=4, sort_keys=True)

    draw_analysis_graph(report, args.dest)
    draw_time_graph(report, args.dest)

if __name__ == '__main__':
    _COLORS = cycle('bgrcmk')
    _ERROR_MARGIN = 0.03
    main()
