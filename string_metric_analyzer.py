import os
import argparse
import json
from subprocess import check_output
from Bio import SeqIO


def get_parser():
    parser = argparse.ArgumentParser(
        description='String metric analyzer based on output from seq_generator.py')
    parser.add_argument(
        'source', action="store", help="Folder generated by seq_generator.py")
    parser.add_argument('metrics', action="store",
                        help="JSON file like {'string_metrics':[metric1, metric2,...]}\
                        where metric{i} is executed with args [seq1, seq2] and match is output")
    parser.add_argument(
        '-d', '--dest', action="store", default="output_metric_analyzer", help="Destination folder")
    return parser


def extract_from_title(title):
    # len_100_p_0.1_1{json}
    splited = title.split("_")
    lenght = int(splited[1])
    p = float(splited[3])
    split_point = splited[4].index("{")
    i = int(splited[4][:split_point])
    diffs = json.loads(splited[4][split_point:])
    return lenght, p, i, diffs


def main():
    args = get_parser().parse_args()
    with open(args.metrics) as json_file:
        try:
            config = json.load(json_file)
        except ValueError:
            print "Config file is not in json format"
            exit()
    if not all(param in config for param in ["string_metrics"]):
        print "Config file missing parameters"
        exit()

    if not os.path.isdir(args.dest):
        os.mkdir(args.dest)
    report = {}
    error, total = 0, 0
    for metric in config["string_metrics"]:
        report.update(
            {metric: {"positive": [], "negative": []}})
        for record in SeqIO.parse(args.source + "/all.fa", "fasta"):
            lenght, error_prob, index, diffs = extract_from_title(record.description)
            for base_records in SeqIO.parse("%s/len_%d_base.fa" % (args.source, lenght), "fasta"):
                base_record = base_records
                break
            match = float(check_output([str(metric), str(record.seq), str(base_record.seq)]))
            if abs(1 - match - error_prob) < ERROR_MARGIN:
                pass
            else:
                error += 1
                report[metric]["negative"].append(
                    ">len_%d_p_%g_%d" % (lenght, error_prob, index))
            total += 1
    print error, "/", total
    with open("%s/report.json" % (args.dest), 'w') as fout:
        json.dump(report, fout)

if __name__ == '__main__':
    ERROR_MARGIN = 0.1
    main()
