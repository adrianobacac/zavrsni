import os
import argparse
import json
from subprocess import check_output
from Bio import SeqIO


def get_parser():
    parser = argparse.ArgumentParser(
        description='String metric analyzer based on output from seq_generator.py')
    parser.add_argument(
        'source', action="store", help="Folder generated by seq_generator.py")
    parser.add_argument('metrics', action="store",
                        help="JSON file like {'string_metrics':[metric1, metric2,...]}\
                        where metric{i} is executed with args [seq1, seq2] and match is output")
    parser.add_argument(
        '-d', '--dest', action="store", default="output_metric_analyzer", help="Destination folder")
    return parser


def extract_from_title(title):
    # len_100_p_0.1_1{json}
    splited = title.split("_")
    lenght = int(splited[1])
    p = float(splited[3])
    split_point = splited[4].index("{")
    i = int(splited[4][:split_point])
    diffs = json.loads(splited[4][split_point:])
    return lenght, p, i, diffs

def main():
    args = get_parser().parse_args()
    with open(args.metrics) as json_file:
        try:
            config = json.load(json_file)
        except ValueError:
            print "Config file is not in json format"
            exit()
    if not all(param in config for param in ["string_metrics"]):
        print "Config file missing parameters"
        exit()

    if not os.path.isdir(args.dest):
        os.mkdir(args.dest)
    report = {}
    for metric in config["string_metrics"]:
        report.update({metric: {"lenghts":{}, "error_probs":{}}})
        for record in SeqIO.parse(args.source + "/all.fa", "fasta"):
            lenght, error_prob, index, diffs = extract_from_title(record.description)
            #set report statistics if lenght or error probability apears for the first time
            if lenght not in report[metric]["lenghts"]:
                    report[metric]["lenghts"].update({lenght:{"bad":0,"total":1}})
            else:
                report[metric]["lenghts"][lenght]["total"]+=1
            if error_prob not in report[metric]["error_probs"]:
                report[metric]["error_probs"].update({error_prob:{"bad":0,"total":1}})
            else:
                report[metric]["error_probs"][error_prob]["total"]+=1

            #get apropriate base record
            for base_records in SeqIO.parse("%s/len_%d_base.fa" % (args.source, lenght), "fasta"):
                base_record = base_records
                break
            #use metric to get match percentage
            match = float(check_output([str(metric), str(record.seq), str(base_record.seq)]))

            if abs(1 - match - error_prob) > ERROR_MARGIN:
                report[metric]["lenghts"][lenght]["bad"]+=1
                report[metric]["error_probs"][error_prob]["bad"]+=1
    with open("%s/report.json" % (args.dest), 'w') as fout:
        json.dump(report, fout)

if __name__ == '__main__':
    ERROR_MARGIN = 0.1
    main()
